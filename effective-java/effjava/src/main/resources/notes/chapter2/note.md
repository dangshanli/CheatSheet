### 考虑使用静态工厂方法替代构造器

所谓静态工厂方法，即使用静态方法返回类实例

```
public static Boolean valueOf(boolean b){
    return b?Boolean.TRUE:Boolean.FALSE;
}
```

构造器和静态工厂方法都可以用来获取实例对象，但是基于静态工厂以下的一些优势，我们应该将其放入
我们的工具箱中


#### 优势一：相比构造器，工厂方法有名字

第一点，方法名可以很好的描述实例的功能，而构造器不能
比如，`BigInteger(int,int,Random)`可能返回素数，那么使用`BigInteger.peobablePrime()`则更加明了

第二点，有时候我们会提供相同签名（参数列表）的构造器，但是其构造过程明显不同，为了以示区分我们只能调整参数顺序。
此时，我们用两个（或者多个）工厂方法将代替构造器提供实例化途径，这样用户可以见名知意的调用不同构造方法，也不易用错

`chapter2.Dog`和`chapter2.Cat`分别展示了构造器和工厂类的不同方式，也可以看出工厂类在某些情况下的一些优势（易读性）

#### 优势二：可以不必每次都新建一个对象

典型的就是单例模式实现的方式，我们使用一个静态成员变量持有(缓存)实例，然后在调用静态工厂的时候返回他.

如果我们需要实现单例，就可以使用这种方式

#### 优势三：返回原返回类型的任何子类型

这一点适用于基于接口的框架(interface-based framework)。即服务接口定义好之后，
工厂类负责返回他的实现类对象，而且可以根据入参不同，调整不同的实现类

这么做的好处之一就是解耦，当我们发现服务接口的更好实现方式的时候(比如开发了一个更牛逼的算法)，我们可以把原来的老方法换成新的实现。
而在工厂方法里面悄悄的将子类替换成新的实现，而对用户完全没有影响，用户也不知道

#### 服务提供者框架

三个主要组件：
- 服务接口(service interface)，即真正提供功能的那些个类
- 提供者注册API(Provider Registration API),一个注册中心，就像一个中心账本，把所有能用的服务类都注册进去，留待别人去查
- 服务访问API(Service Access API)，就是我们的前面的静态工厂，专门提供服务类的实例
- Service Provider Interface,服务提供者接口，负责创建其服务实现的实例，可选组件

`chapter2.interface_based_frame`包下面的代码展示了服务提供者框架的基本成分

### 静态工厂的缺陷

第一点，如果一个类不包含`public`或者`protected`的构造器，无法被继承(因为子类实例化时，会先尝试实例化父类)。
而静态工厂一般偏偏是禁止实例化的。因此，如果想继承任何Collection框架的工具类，都是不可能的

第二点，静态工厂方法在文档导出的时候会被当成一般的静态。这样猛一看文档很难找到那个真正用来获取实例的方法，工厂方法躺在一般静态方法中泯然众人


### 常见的静态工厂方法命名方式
- valueOf
- of
- getInstance
- newInstance
- getType
- newType

