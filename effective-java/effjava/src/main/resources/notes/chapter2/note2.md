### 构造方法的入参巨多的时候考虑使用构建器(builder)

#### 定义
**构建器**：即用来替代直接构造方法的方式，重新包装初始化以及实例化过程的方法

#### 应用场景
**场景**：构造方法的参数很多（3、4个以上），而且有相当一部分属于可选的时候，考虑使用构建起来替代直接使用多个构造方法的方式，
则会使代码更加的易于编写、增强可读性、不易被错误调用

#### 例子

我们使用一个类去表达一种饮料的成分（这种成分可能多达几十种），而且部分成分是必选成分，有些是可选成分。
比如，水、卡路里是必须的，而脂肪、胆固醇、钠等是可选的。对于这些可选的参数，我们可能初始化一个、也可能好几个、或者一个也不用。
##### 重叠的多个构造方法

对于上面的情况，每一个构造函数就对应一种可选成分的表达方案（初始化哪几种可选成分），那样我们就需要多个功能重叠（仅仅入参不同）的构造器

如`chapter2.NutritionFacts1`所示，我们针对可选的成员，写了一系列重叠的构造器。
这种方式主要缺陷有：
    - 随着参数的增加，构造器也会膨胀起来，很难编写、阅读(估计即使类的创建者一段时间再去调用自己写的类，不看注释的情况，都能给搞晕了)
    - 参数列表极长，很容易混淆，导致数值传错之类的，即很难调用
    
#### 使用JavaBean
如`chapter2.NutritionFacts2`所示，javaBean很好的解决了构造器地狱的问题，但是也带来一些其他的问题

第一点，将构造对象的过程分不到几个独立的setter中，构造过程中JavaBean处于不一致状态，无法通过参数有效性来保持一致性。我对这句话的理解是，
由于每个成员的初始化都需要调用者主动调用一个setter方法，对比构造器强制要求某些参数，而setter是很随意的调用，因此setter方式可能造成初始化
对象错误。但是我觉得问题不大，因为你既然调用这个类，一定很清楚你需要哪些东西

第二点，setter破坏了"把类做成不可变对象" 的一个准则

#### builder模式

Builder模式采用内部静态类作为初始化参数的入口，builder内部创建多个setter方法。外部类创建一个private构造器，入参为Builder。
Builder内部创建一个`build()`方法来调用外部类的构造函数

这样做的话至少有几点好处：
- 不会在类内部产生构造器地狱
- 外部类由于private构造函数，转而在Builder内部setter参数，因此保持了对象的不可变

如`chapter2.NutritionFacts3`所示

缺陷：
 - 由于在每次实例化前需要构建Builder对象，这是一笔开销，如果你对性能有一定需求，那么Builder可能成为负担
 - Builder需要单独花费代码构建，如果只是简单地几个参数，就不值得那么去做